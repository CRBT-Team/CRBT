generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model timeouts {
  expiration DateTime     @db.Timestamptz(6)
  locale     String
  type       TimeoutTypes
  data       Json         @db.Json
  id         String       @id
}

model servers {
  id           String         @id
  joinChannel  String?        @map("join_channel")
  joinMessage  Json?          @map("join_message")
  leaveChannel String?        @map("leave_channel")
  leaveMessage Json?          @map("leave_message")
  accentColor  String?        @map("accent_color")
  economy      Economy?
  modules      serverModules?
  // achievements Achievement[]
  flags        BigInt?        @default(0)
}

model serverModules {
  id           String  @id
  joinMessage  Boolean @default(false) @map("join_message")
  leaveMessage Boolean @default(false) @map("leave_message")
  server       servers @relation(fields: [id], references: [id])
}

model moderationStrikes {
  id          String                @id @default(uuid()) @db.Uuid
  moderatorId String                @map("moderator_id")
  serverId    String                @map("server_id")
  targetId    String                @map("target_id")
  reason      String?
  createdAt   DateTime              @map("created_at") @db.Timestamptz(6)
  expiresAt   DateTime?             @map("expires_at") @db.Timestamptz(6)
  type        ModerationStrikeTypes
}

model users {
  id                    String         @id(map: "misc_pkey")
  guildedId             String?        @map("guilded_id")
  accentColor           String?        @map("accent_color")
  achievements          Achievements[]
  birthday              DateTime?      @db.Timestamptz(6)
  crbtBadges            String[]       @map("crbt_badges")
  telemetry             Boolean        @default(true)
  silentJoins           Boolean        @default(false) @map("silent_joins")
  silentLeaves          Boolean        @default(false) @map("silent_leaves")
  subscriptionExpiresAt DateTime?      @map("sub_expiration")
}

model Statistics {
  date         DateTime @unique
  servers      Int
  uniqueUsers  String[]
  commandsUsed String[]
  members      Int
}

model Achievements {
  id          String    @id
  userId      String    @map("user_id")
  user        users     @relation(fields: [userId], references: [id])
  achievement String
  progression Int
  // totalSteps  Int
  achievedAt  DateTime? @map("achieved_at") @db.Timestamptz(6)
}

// model Achievement {
//   id         String   @id
//   serverId   String   @map("server_id")
//   userId     String   @map("user_id")
//   server     servers? @relation(fields: [serverId], references: [id])
//   users      users[]
//   totalSteps Int
// }

model Inventory {
  serverId    String        @id @map("server_id")
  userId      String        @map("user_id")
  dailyStreak Int           @default(0) @map("daily_streak") @db.SmallInt
  activeItems EconomyItem[] @relation("ActiveInventory")
  items       EconomyItem[] @relation("Inventory")
}

model Economy {
  serverId             String  @id
  currencyNameSingular String  @map("currency_name_singular")
  currencyNamePlural   String  @map("currency_name_plural")
  currencySymbol       String  @map("currency_symbol")
  server               servers @relation(fields: [serverId], references: [id])
}

model EconomyCommand {
  serverId String          @id @map("server_id")
  type     EconomyCommands
  enabled  Boolean         @default(true)
  strings  String[]
  cooldown Int             @default(20000)
  minGain  Int             @default(50) @map("min_gain")
  maxGain  Int             @default(100) @map("max_gain")
}

model EconomyItem {
  id                        BigInt     @id @default(autoincrement())
  serverId                  String     @map("server_id")
  name                      String
  icon                      String?
  description               String?
  price                     Int
  category                  String
  type                      ItemTypes
  stock                     Int
  // for items limited in time
  availableUntil            DateTime?  @map("available_until") @db.Timestamptz(6)
  // the value an item can hold (role ID, Multiplier, etc)
  value                     String?
  inventoriesServerId       String?    @map("inventories_server_id")
  activeInventoriesServerId String?    @map("active_inventories_server_id")
  activeInventories         Inventory? @relation("ActiveInventory", fields: [activeInventoriesServerId], references: [serverId])
  inventories               Inventory? @relation("Inventory", fields: [inventoriesServerId], references: [serverId])
}

model Token {
  token String     @id
  data  Json       @db.Json
  type  TokenTypes
}

enum TimeoutTypes {
  REMINDER
  POLL
  TEMPBAN
  GIVEAWAY
}

enum ModerationStrikeTypes {
  BAN
  TEMPBAN
  CLEAR
  KICK
  TIMEOUT
  WARN
}

enum EconomyCommands {
  work
  hourly
  crime
}

enum ItemTypes {
  ROLE
  WEAPON
  INCOME_MULTIPLIER
  COSMETIC
  OTHER
}

enum TokenTypes {
  API
  REDEEM
}
